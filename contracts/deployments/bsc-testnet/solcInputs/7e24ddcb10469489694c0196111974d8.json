{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/AIOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"./interfaces/IAIOracle.sol\";\r\nimport \"./PredictionMarket.sol\";\r\n\r\ncontract AIOracle is IAIOracle, Ownable, ReentrancyGuard {\r\n    struct AIResult {\r\n        uint256 predictedOutcome;\r\n        uint256 confidence; // 0-100\r\n        uint256 timestamp;\r\n        bool isSubmitted;\r\n        string evidence;\r\n        address submitter;\r\n    }\r\n\r\n    struct AgentReport {\r\n        address agent;\r\n        uint256 outcome;\r\n        uint256 confidence;\r\n        string data;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    // State variables\r\n    mapping(address => AIResult) public aiResults; // market => result\r\n    mapping(address => mapping(address => AgentReport)) public agentReports; // market => agent => report\r\n    mapping(address => address[]) public marketAgents; // market => agents[]\r\n    mapping(address => bool) public authorizedAgents;\r\n    mapping(address => uint256) public agentReputation; // 0-1000 reputation score\r\n    \r\n    uint256 public minimumConfidence;\r\n    uint256 public minimumAgents;\r\n    uint256 public consensusThreshold; // Percentage needed for consensus\r\n    \r\n    // Events\r\n    event AIResultSubmitted(\r\n        address indexed market,\r\n        uint256 outcome,\r\n        uint256 confidence,\r\n        address submitter\r\n    );\r\n    \r\n    event AgentReportSubmitted(\r\n        address indexed market,\r\n        address indexed agent,\r\n        uint256 outcome,\r\n        uint256 confidence\r\n    );\r\n    \r\n    event AgentAuthorized(address indexed agent, uint256 reputation);\r\n    event AgentDeauthorized(address indexed agent);\r\n    event ConsensusReached(address indexed market, uint256 outcome, uint256 confidence);\r\n\r\n    modifier onlyAuthorizedAgent() {\r\n        require(authorizedAgents[msg.sender], \"Not authorized agent\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        uint256 _minimumConfidence,\r\n        uint256 _minimumAgents,\r\n        uint256 _consensusThreshold\r\n    ) Ownable(msg.sender) {\r\n        minimumConfidence = _minimumConfidence;\r\n        minimumAgents = _minimumAgents;\r\n        consensusThreshold = _consensusThreshold;\r\n    }\r\n\r\n    /**\r\n     * @dev Submit AI analysis result for a market\r\n     * @param _market Address of the prediction market\r\n     * @param _predictedOutcome Predicted winning outcome\r\n     * @param _confidence Confidence level (0-100)\r\n     * @param _evidence Supporting evidence/data\r\n     */\r\n    function submitAIResult(\r\n        address _market,\r\n        uint256 _predictedOutcome,\r\n        uint256 _confidence,\r\n        string memory _evidence\r\n    ) external override onlyAuthorizedAgent nonReentrant {\r\n        require(_confidence >= minimumConfidence, \"Confidence too low\");\r\n        require(_confidence <= 100, \"Invalid confidence level\");\r\n        \r\n        // Submit agent report\r\n        agentReports[_market][msg.sender] = AgentReport({\r\n            agent: msg.sender,\r\n            outcome: _predictedOutcome,\r\n            confidence: _confidence,\r\n            data: _evidence,\r\n            timestamp: block.timestamp\r\n        });\r\n\r\n        // Add agent to market if not already added\r\n        if (!_isAgentInMarket(_market, msg.sender)) {\r\n            marketAgents[_market].push(msg.sender);\r\n        }\r\n\r\n        emit AgentReportSubmitted(_market, msg.sender, _predictedOutcome, _confidence);\r\n\r\n        // Check if we have enough reports to reach consensus\r\n        _checkConsensus(_market);\r\n    }\r\n\r\n    /**\r\n     * @dev Get AI result for a market\r\n     */\r\n    function getAIResult(address _market) \r\n        external \r\n        view \r\n        override \r\n        returns (uint256 outcome, uint256 confidence, bool isSubmitted) \r\n    {\r\n        AIResult memory result = aiResults[_market];\r\n        return (result.predictedOutcome, result.confidence, result.isSubmitted);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if consensus has been reached and submit final result\r\n     */\r\n    function _checkConsensus(address _market) internal {\r\n        address[] memory agents = marketAgents[_market];\r\n        \r\n        if (agents.length < minimumAgents) {\r\n            return; // Not enough agents yet\r\n        }\r\n\r\n        // Calculate consensus\r\n        (uint256 consensusOutcome, uint256 avgConfidence, bool hasConsensus) = \r\n            _calculateConsensus(_market, agents);\r\n\r\n        if (hasConsensus && !aiResults[_market].isSubmitted) {\r\n            // Submit final AI result\r\n            aiResults[_market] = AIResult({\r\n                predictedOutcome: consensusOutcome,\r\n                confidence: avgConfidence,\r\n                timestamp: block.timestamp,\r\n                isSubmitted: true,\r\n                evidence: \"AI consensus reached\",\r\n                submitter: address(this)\r\n            });\r\n\r\n            emit AIResultSubmitted(_market, consensusOutcome, avgConfidence, address(this));\r\n            emit ConsensusReached(_market, consensusOutcome, avgConfidence);\r\n\r\n            // Automatically resolve market if it's expired\r\n            _attemptMarketResolution(_market, consensusOutcome);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate consensus from agent reports\r\n     */\r\n    function _calculateConsensus(address _market, address[] memory agents) \r\n        internal \r\n        view \r\n        returns (uint256 outcome, uint256 confidence, bool hasConsensus) \r\n    {\r\n        if (agents.length == 0) return (0, 0, false);\r\n\r\n        uint256 totalWeight = 0;\r\n        uint256 totalConfidence = 0;\r\n        uint256 validReports = 0;\r\n\r\n        // Find maximum outcome to determine array size\r\n        uint256 maxOutcome = 0;\r\n        for (uint256 i = 0; i < agents.length; i++) {\r\n            AgentReport memory report = agentReports[_market][agents[i]];\r\n            if (report.timestamp > 0) {\r\n                if (report.outcome > maxOutcome) {\r\n                    maxOutcome = report.outcome;\r\n                }\r\n                validReports++;\r\n            }\r\n        }\r\n\r\n        if (validReports == 0) return (0, 0, false);\r\n\r\n        // Use arrays for vote counting\r\n        uint256[] memory votes = new uint256[](maxOutcome + 1);\r\n        \r\n        for (uint256 i = 0; i < agents.length; i++) {\r\n            AgentReport memory report = agentReports[_market][agents[i]];\r\n            if (report.timestamp > 0) {\r\n                uint256 agentRep = agentReputation[agents[i]];\r\n                if (agentRep == 0) agentRep = 100; // Default reputation\r\n                \r\n                uint256 weight = (agentRep * report.confidence) / 100;\r\n                votes[report.outcome] += weight;\r\n                totalWeight += weight;\r\n                totalConfidence += report.confidence;\r\n            }\r\n        }\r\n\r\n        // Find outcome with most votes\r\n        uint256 maxVotes = 0;\r\n        uint256 winningOutcome = 0;\r\n        \r\n        for (uint256 i = 0; i <= maxOutcome; i++) {\r\n            if (votes[i] > maxVotes) {\r\n                maxVotes = votes[i];\r\n                winningOutcome = i;\r\n            }\r\n        }\r\n\r\n        // Check if consensus threshold is met\r\n        uint256 consensusPercentage = (maxVotes * 100) / totalWeight;\r\n        bool consensus = consensusPercentage >= consensusThreshold;\r\n        \r\n        uint256 avgConf = totalConfidence / validReports;\r\n        \r\n        return (winningOutcome, avgConf, consensus);\r\n    }\r\n\r\n    /**\r\n     * @dev Attempt to resolve market with AI result\r\n     */\r\n    function _attemptMarketResolution(address _market, uint256 _outcome) internal {\r\n        try PredictionMarket(_market).resolveMarket(_outcome, \"AI Oracle Resolution\") {\r\n            // Market resolved successfully\r\n        } catch {\r\n            // Market resolution failed, possibly not expired yet\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Check if agent is already in market's agent list\r\n     */\r\n    function _isAgentInMarket(address _market, address _agent) internal view returns (bool) {\r\n        address[] memory agents = marketAgents[_market];\r\n        for (uint256 i = 0; i < agents.length; i++) {\r\n            if (agents[i] == _agent) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Authorize an AI agent\r\n     */\r\n    function authorizeAgent(address _agent, uint256 _reputation) external onlyOwner {\r\n        require(_agent != address(0), \"Invalid agent address\");\r\n        require(_reputation <= 1000, \"Invalid reputation score\");\r\n        \r\n        authorizedAgents[_agent] = true;\r\n        agentReputation[_agent] = _reputation;\r\n        \r\n        emit AgentAuthorized(_agent, _reputation);\r\n    }\r\n\r\n    /**\r\n     * @dev Deauthorize an AI agent\r\n     */\r\n    function deauthorizeAgent(address _agent) external onlyOwner {\r\n        authorizedAgents[_agent] = false;\r\n        agentReputation[_agent] = 0;\r\n        \r\n        emit AgentDeauthorized(_agent);\r\n    }\r\n\r\n    /**\r\n     * @dev Update agent reputation based on performance\r\n     */\r\n    function updateAgentReputation(address _agent, uint256 _newReputation) external onlyOwner {\r\n        require(authorizedAgents[_agent], \"Agent not authorized\");\r\n        require(_newReputation <= 1000, \"Invalid reputation score\");\r\n        \r\n        agentReputation[_agent] = _newReputation;\r\n    }\r\n\r\n    /**\r\n     * @dev Update oracle parameters\r\n     */\r\n    function updateParameters(\r\n        uint256 _minimumConfidence,\r\n        uint256 _minimumAgents,\r\n        uint256 _consensusThreshold\r\n    ) external onlyOwner {\r\n        require(_minimumConfidence <= 100, \"Invalid confidence\");\r\n        require(_consensusThreshold <= 100, \"Invalid threshold\");\r\n        \r\n        minimumConfidence = _minimumConfidence;\r\n        minimumAgents = _minimumAgents;\r\n        consensusThreshold = _consensusThreshold;\r\n    }\r\n\r\n    /**\r\n     * @dev Get market agents\r\n     */\r\n    function getMarketAgents(address _market) external view returns (address[] memory) {\r\n        return marketAgents[_market];\r\n    }\r\n\r\n    /**\r\n     * @dev Get agent report for market\r\n     */\r\n    function getAgentReport(address _market, address _agent) \r\n        external \r\n        view \r\n        returns (AgentReport memory) \r\n    {\r\n        return agentReports[_market][_agent];\r\n    }\r\n\r\n    /**\r\n     * @dev Force consensus calculation (for testing/emergency)\r\n     */\r\n    function forceConsensusCheck(address _market) external onlyOwner {\r\n        _checkConsensus(_market);\r\n    }\r\n\r\n    /**\r\n     * @dev Manual result submission (fallback)\r\n     */\r\n    function submitManualResult(\r\n        address _market,\r\n        uint256 _outcome,\r\n        uint256 _confidence,\r\n        string memory _evidence\r\n    ) external onlyOwner {\r\n        require(!aiResults[_market].isSubmitted, \"Result already submitted\");\r\n        \r\n        aiResults[_market] = AIResult({\r\n            predictedOutcome: _outcome,\r\n            confidence: _confidence,\r\n            timestamp: block.timestamp,\r\n            isSubmitted: true,\r\n            evidence: _evidence,\r\n            submitter: msg.sender\r\n        });\r\n\r\n        emit AIResultSubmitted(_market, _outcome, _confidence, msg.sender);\r\n        \r\n        _attemptMarketResolution(_market, _outcome);\r\n    }\r\n}"
    },
    "contracts/DisputeResolution.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./StakingContract.sol\";\r\nimport \"./PredictionMarket.sol\";\r\n\r\ncontract DisputeResolution is ReentrancyGuard, Ownable {\r\n    enum DisputeStatus { Open, Voting, Resolved, Rejected }\r\n    enum VoteChoice { NoVote, Uphold, Overturn }\r\n\r\n    struct Dispute {\r\n        address market;\r\n        address disputer;\r\n        uint256 disputedOutcome;\r\n        uint256 proposedOutcome;\r\n        string reason;\r\n        uint256 disputeBond;\r\n        uint256 createdAt;\r\n        uint256 votingEndsAt;\r\n        DisputeStatus status;\r\n        uint256 upholdVotes;\r\n        uint256 overturnVotes;\r\n        uint256 totalVotingPower;\r\n        bool resolved;\r\n        uint256 finalOutcome;\r\n    }\r\n\r\n    struct Vote {\r\n        VoteChoice choice;\r\n        uint256 votingPower;\r\n        uint256 timestamp;\r\n        bool claimed;\r\n    }\r\n\r\n    // State variables\r\n    mapping(uint256 => Dispute) public disputes;\r\n    mapping(uint256 => mapping(address => Vote)) public votes; // disputeId => voter => vote\r\n    mapping(uint256 => address[]) public disputeVoters; // disputeId => voters[]\r\n    \r\n    uint256 public disputeCounter;\r\n    uint256 public minimumDisputeBond;\r\n    uint256 public votingPeriod;\r\n    uint256 public minimumVotingPower;\r\n    uint256 public quorumThreshold; // Percentage of total voting power needed\r\n    \r\n    IERC20 public orxToken;\r\n    StakingContract public stakingContract;\r\n    \r\n    // Events\r\n    event DisputeOpened(\r\n        uint256 indexed disputeId,\r\n        address indexed market,\r\n        address indexed disputer,\r\n        uint256 disputedOutcome,\r\n        uint256 proposedOutcome\r\n    );\r\n    \r\n    event VoteCast(\r\n        uint256 indexed disputeId,\r\n        address indexed voter,\r\n        VoteChoice choice,\r\n        uint256 votingPower\r\n    );\r\n    \r\n    event DisputeResolved(\r\n        uint256 indexed disputeId,\r\n        bool upheld,\r\n        uint256 finalOutcome\r\n    );\r\n    \r\n    event RewardsDistributed(uint256 indexed disputeId, uint256 totalRewards);\r\n\r\n    modifier onlyActiveValidator() {\r\n        require(stakingContract.isActiveValidator(msg.sender), \"Not an active validator\");\r\n        _;\r\n    }\r\n\r\n    modifier disputeExists(uint256 _disputeId) {\r\n        require(_disputeId < disputeCounter, \"Dispute does not exist\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _orxToken,\r\n        address _stakingContract,\r\n        uint256 _minimumDisputeBond,\r\n        uint256 _votingPeriod,\r\n        uint256 _quorumThreshold\r\n    ) Ownable(msg.sender) {\r\n        orxToken = IERC20(_orxToken);\r\n        stakingContract = StakingContract(_stakingContract);\r\n        minimumDisputeBond = _minimumDisputeBond;\r\n        votingPeriod = _votingPeriod;\r\n        quorumThreshold = _quorumThreshold;\r\n        minimumVotingPower = 1000 * 1e18; // 1000 ORX minimum\r\n    }\r\n\r\n    /**\r\n     * @dev Open a dispute for a market resolution\r\n     * @param _market Address of the prediction market\r\n     * @param _disputedOutcome Current outcome being disputed\r\n     * @param _proposedOutcome Proposed correct outcome\r\n     * @param _reason Reason for the dispute\r\n     */\r\n    function openDispute(\r\n        address _market,\r\n        uint256 _disputedOutcome,\r\n        uint256 _proposedOutcome,\r\n        string memory _reason\r\n    ) external payable nonReentrant returns (uint256) {\r\n        require(msg.value >= minimumDisputeBond, \"Insufficient dispute bond\");\r\n        require(_disputedOutcome != _proposedOutcome, \"Outcomes cannot be the same\");\r\n        require(bytes(_reason).length > 0, \"Reason required\");\r\n\r\n        // Verify market status\r\n        (,,,, PredictionMarket.MarketStatus status,,) = PredictionMarket(_market).getMarketInfo();\r\n        require(status == PredictionMarket.MarketStatus.Resolved, \"Market not resolved\");\r\n\r\n        uint256 disputeId = disputeCounter++;\r\n        \r\n        disputes[disputeId] = Dispute({\r\n            market: _market,\r\n            disputer: msg.sender,\r\n            disputedOutcome: _disputedOutcome,\r\n            proposedOutcome: _proposedOutcome,\r\n            reason: _reason,\r\n            disputeBond: msg.value,\r\n            createdAt: block.timestamp,\r\n            votingEndsAt: block.timestamp + votingPeriod,\r\n            status: DisputeStatus.Voting,\r\n            upholdVotes: 0,\r\n            overturnVotes: 0,\r\n            totalVotingPower: 0,\r\n            resolved: false,\r\n            finalOutcome: _disputedOutcome\r\n        });\r\n\r\n        emit DisputeOpened(disputeId, _market, msg.sender, _disputedOutcome, _proposedOutcome);\r\n\r\n        return disputeId;\r\n    }\r\n\r\n    /**\r\n     * @dev Vote on a dispute\r\n     * @param _disputeId ID of the dispute\r\n     * @param _choice Vote choice (Uphold or Overturn)\r\n     */\r\n    function voteOnDispute(uint256 _disputeId, VoteChoice _choice) \r\n        external \r\n        nonReentrant \r\n        disputeExists(_disputeId)\r\n        onlyActiveValidator \r\n    {\r\n        require(_choice != VoteChoice.NoVote, \"Invalid vote choice\");\r\n        \r\n        Dispute storage dispute = disputes[_disputeId];\r\n        require(dispute.status == DisputeStatus.Voting, \"Voting period ended\");\r\n        require(block.timestamp <= dispute.votingEndsAt, \"Voting period expired\");\r\n        require(votes[_disputeId][msg.sender].choice == VoteChoice.NoVote, \"Already voted\");\r\n\r\n        // Calculate voting power based on stake and reputation\r\n        StakingContract.StakeInfo memory stakeInfo = stakingContract.getStakeInfo(msg.sender);\r\n        StakingContract.Validator memory validatorInfo = stakingContract.getValidatorInfo(msg.sender);\r\n        \r\n        require(stakeInfo.amount >= minimumVotingPower, \"Insufficient voting power\");\r\n        \r\n        // Voting power = staked amount * reputation factor\r\n        uint256 votingPower = (stakeInfo.amount * validatorInfo.reputation) / 1000;\r\n\r\n        // Record vote\r\n        votes[_disputeId][msg.sender] = Vote({\r\n            choice: _choice,\r\n            votingPower: votingPower,\r\n            timestamp: block.timestamp,\r\n            claimed: false\r\n        });\r\n\r\n        disputeVoters[_disputeId].push(msg.sender);\r\n\r\n        // Update vote tallies\r\n        if (_choice == VoteChoice.Uphold) {\r\n            dispute.upholdVotes += votingPower;\r\n        } else if (_choice == VoteChoice.Overturn) {\r\n            dispute.overturnVotes += votingPower;\r\n        }\r\n\r\n        dispute.totalVotingPower += votingPower;\r\n\r\n        emit VoteCast(_disputeId, msg.sender, _choice, votingPower);\r\n    }\r\n\r\n    /**\r\n     * @dev Finalize a dispute after voting period\r\n     * @param _disputeId ID of the dispute to finalize\r\n     */\r\n    function finalizeDispute(uint256 _disputeId) \r\n        external \r\n        nonReentrant \r\n        disputeExists(_disputeId) \r\n    {\r\n        Dispute storage dispute = disputes[_disputeId];\r\n        require(dispute.status == DisputeStatus.Voting, \"Dispute not in voting phase\");\r\n        require(block.timestamp > dispute.votingEndsAt, \"Voting period not ended\");\r\n        require(!dispute.resolved, \"Dispute already resolved\");\r\n\r\n        // Check if quorum was reached\r\n        uint256 totalStaked = orxToken.balanceOf(address(stakingContract));\r\n        uint256 quorumRequired = (totalStaked * quorumThreshold) / 100;\r\n        \r\n        if (dispute.totalVotingPower < quorumRequired) {\r\n            dispute.status = DisputeStatus.Rejected;\r\n            // Return dispute bond to disputer\r\n            (bool success, ) = payable(dispute.disputer).call{value: dispute.disputeBond}(\"\");\r\n            require(success, \"Bond return failed\");\r\n            \r\n            emit DisputeResolved(_disputeId, false, dispute.finalOutcome);\r\n        } else {\r\n            // Determine outcome based on votes\r\n            bool upheld = dispute.upholdVotes > dispute.overturnVotes;\r\n            \r\n            if (upheld) {\r\n                dispute.status = DisputeStatus.Resolved;\r\n                dispute.finalOutcome = dispute.disputedOutcome;\r\n                // Return dispute bond to disputer (they were wrong)\r\n                (bool success, ) = payable(dispute.disputer).call{value: dispute.disputeBond}(\"\");\r\n                require(success, \"Bond return failed\");\r\n            } else {\r\n                dispute.status = DisputeStatus.Resolved;\r\n                dispute.finalOutcome = dispute.proposedOutcome;\r\n                \r\n                // Update market with new outcome - this would require market to have an update function\r\n                // For now, we'll just record the decision\r\n                \r\n                // Reward the disputer with their bond back plus bonus\r\n                uint256 reward = dispute.disputeBond + (dispute.disputeBond / 2); // 50% bonus\r\n                (bool success, ) = payable(dispute.disputer).call{value: reward}(\"\");\r\n                require(success, \"Reward transfer failed\");\r\n            }\r\n            \r\n            dispute.resolved = true;\r\n            _distributeVotingRewards(_disputeId, upheld);\r\n            \r\n            emit DisputeResolved(_disputeId, upheld, dispute.finalOutcome);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Distribute rewards to winning voters\r\n     */\r\n    function _distributeVotingRewards(uint256 _disputeId, bool _upheld) internal {\r\n        Dispute storage dispute = disputes[_disputeId];\r\n        address[] memory voters = disputeVoters[_disputeId];\r\n        \r\n        uint256 winningVotes = _upheld ? dispute.upholdVotes : dispute.overturnVotes;\r\n        uint256 totalReward = dispute.disputeBond / 4; // 25% of dispute bond as reward pool\r\n        \r\n        if (winningVotes == 0) return;\r\n        \r\n        for (uint256 i = 0; i < voters.length; i++) {\r\n            address voter = voters[i];\r\n            Vote storage vote = votes[_disputeId][voter];\r\n            \r\n            bool wonVote = (_upheld && vote.choice == VoteChoice.Uphold) || \r\n                          (!_upheld && vote.choice == VoteChoice.Overturn);\r\n            \r\n            if (wonVote && !vote.claimed) {\r\n                uint256 voterReward = (vote.votingPower * totalReward) / winningVotes;\r\n                vote.claimed = true;\r\n                \r\n                // Transfer ORX tokens as reward\r\n                orxToken.transfer(voter, voterReward);\r\n            }\r\n        }\r\n        \r\n        emit RewardsDistributed(_disputeId, totalReward);\r\n    }\r\n\r\n    /**\r\n     * @dev Claim voting rewards manually\r\n     */\r\n    function claimVotingReward(uint256 _disputeId) external nonReentrant disputeExists(_disputeId) {\r\n        require(disputes[_disputeId].resolved, \"Dispute not resolved\");\r\n        require(!votes[_disputeId][msg.sender].claimed, \"Reward already claimed\");\r\n        \r\n        Dispute storage dispute = disputes[_disputeId];\r\n        Vote storage vote = votes[_disputeId][msg.sender];\r\n        \r\n        bool upheld = dispute.upholdVotes > dispute.overturnVotes;\r\n        bool wonVote = (upheld && vote.choice == VoteChoice.Uphold) || \r\n                      (!upheld && vote.choice == VoteChoice.Overturn);\r\n        \r\n        require(wonVote, \"Did not win the vote\");\r\n        \r\n        uint256 winningVotes = upheld ? dispute.upholdVotes : dispute.overturnVotes;\r\n        uint256 totalReward = dispute.disputeBond / 4;\r\n        uint256 voterReward = (vote.votingPower * totalReward) / winningVotes;\r\n        \r\n        vote.claimed = true;\r\n        orxToken.transfer(msg.sender, voterReward);\r\n    }\r\n\r\n    /**\r\n     * @dev Get dispute information\r\n     */\r\n    function getDispute(uint256 _disputeId) external view returns (Dispute memory) {\r\n        return disputes[_disputeId];\r\n    }\r\n\r\n    /**\r\n     * @dev Get vote information\r\n     */\r\n    function getVote(uint256 _disputeId, address _voter) external view returns (Vote memory) {\r\n        return votes[_disputeId][_voter];\r\n    }\r\n\r\n    /**\r\n     * @dev Get all voters for a dispute\r\n     */\r\n    function getDisputeVoters(uint256 _disputeId) external view returns (address[] memory) {\r\n        return disputeVoters[_disputeId];\r\n    }\r\n\r\n    /**\r\n     * @dev Check if user can vote on dispute\r\n     */\r\n    function canVote(uint256 _disputeId, address _voter) external view returns (bool) {\r\n        if (_disputeId >= disputeCounter) return false;\r\n        \r\n        Dispute memory dispute = disputes[_disputeId];\r\n        if (dispute.status != DisputeStatus.Voting) return false;\r\n        if (block.timestamp > dispute.votingEndsAt) return false;\r\n        if (votes[_disputeId][_voter].choice != VoteChoice.NoVote) return false;\r\n        if (!stakingContract.isActiveValidator(_voter)) return false;\r\n        \r\n        StakingContract.StakeInfo memory stakeInfo = stakingContract.getStakeInfo(_voter);\r\n        return stakeInfo.amount >= minimumVotingPower;\r\n    }\r\n\r\n    /**\r\n     * @dev Update contract parameters\r\n     */\r\n    function updateParameters(\r\n        uint256 _minimumDisputeBond,\r\n        uint256 _votingPeriod,\r\n        uint256 _quorumThreshold,\r\n        uint256 _minimumVotingPower\r\n    ) external onlyOwner {\r\n        minimumDisputeBond = _minimumDisputeBond;\r\n        votingPeriod = _votingPeriod;\r\n        quorumThreshold = _quorumThreshold;\r\n        minimumVotingPower = _minimumVotingPower;\r\n    }\r\n\r\n    /**\r\n     * @dev Emergency withdrawal of contract funds\r\n     */\r\n    function emergencyWithdraw() external onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        (bool success, ) = payable(owner()).call{value: balance}(\"\");\r\n        require(success, \"Withdrawal failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Get total disputes count\r\n     */\r\n    function getTotalDisputes() external view returns (uint256) {\r\n        return disputeCounter;\r\n    }\r\n\r\n    /**\r\n     * @dev Get active disputes\r\n     */\r\n    function getActiveDisputes() external view returns (uint256[] memory) {\r\n        uint256 activeCount = 0;\r\n        \r\n        // Count active disputes\r\n        for (uint256 i = 0; i < disputeCounter; i++) {\r\n            if (disputes[i].status == DisputeStatus.Voting) {\r\n                activeCount++;\r\n            }\r\n        }\r\n        \r\n        // Build active disputes array\r\n        uint256[] memory activeDisputes = new uint256[](activeCount);\r\n        uint256 index = 0;\r\n        \r\n        for (uint256 i = 0; i < disputeCounter; i++) {\r\n            if (disputes[i].status == DisputeStatus.Voting) {\r\n                activeDisputes[index] = i;\r\n                index++;\r\n            }\r\n        }\r\n        \r\n        return activeDisputes;\r\n    }\r\n}"
    },
    "contracts/interfaces/IAIOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\ninterface IAIOracle {\r\n    function submitAIResult(\r\n        address _market,\r\n        uint256 _predictedOutcome,\r\n        uint256 _confidence,\r\n        string memory _evidence\r\n    ) external;\r\n\r\n    function getAIResult(address _market) \r\n        external \r\n        view \r\n        returns (uint256 outcome, uint256 confidence, bool isSubmitted);\r\n}"
    },
    "contracts/PredictionMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\r\nimport \"./interfaces/IAIOracle.sol\";\r\n\r\ncontract PredictionMarket is ReentrancyGuard, Pausable {\r\n    enum MarketStatus { Active, Resolved, Disputed, Cancelled }\r\n    enum OracleType { AI, Manual, Hybrid }\r\n\r\n    struct Bet {\r\n        uint256 amount;\r\n        uint256 outcome;\r\n        uint256 timestamp;\r\n        bool claimed;\r\n    }\r\n\r\n    struct Outcome {\r\n        string name;\r\n        uint256 totalStaked;\r\n        uint256 betCount;\r\n    }\r\n\r\n    // State variables\r\n    string public title;\r\n    string public description;\r\n    Outcome[] public outcomes;\r\n    uint256 public expiryTime;\r\n    address public creator;\r\n    address public factory;\r\n    address public oracleAddress;\r\n    OracleType public oracleType;\r\n    MarketStatus public status;\r\n    \r\n    uint256 public totalVolume;\r\n    uint256 public winningOutcome;\r\n    uint256 public resolutionTime;\r\n    uint256 public platformFeeRate; // Basis points (e.g., 250 = 2.5%)\r\n    \r\n    mapping(address => Bet[]) public userBets;\r\n    mapping(address => uint256) public userTotalStaked;\r\n    mapping(uint256 => uint256) public outcomeStaked;\r\n    \r\n    address[] public participants;\r\n    mapping(address => bool) public hasParticipated;\r\n\r\n    // Events\r\n    event BetPlaced(\r\n        address indexed user,\r\n        uint256 indexed outcome,\r\n        uint256 amount,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event MarketResolved(\r\n        uint256 indexed winningOutcome,\r\n        uint256 timestamp,\r\n        string resolution\r\n    );\r\n    \r\n    event RewardClaimed(\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event MarketDisputed(\r\n        address indexed disputer,\r\n        uint256 timestamp,\r\n        string reason\r\n    );\r\n\r\n    event MarketCancelled(uint256 timestamp, string reason);\r\n\r\n    modifier onlyCreator() {\r\n        require(msg.sender == creator, \"Only market creator allowed\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFactory() {\r\n        require(msg.sender == factory, \"Only factory allowed\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOracle() {\r\n        require(msg.sender == oracleAddress, \"Only oracle allowed\");\r\n        _;\r\n    }\r\n\r\n    modifier marketActive() {\r\n        require(status == MarketStatus.Active, \"Market not active\");\r\n        require(block.timestamp < expiryTime, \"Market expired\");\r\n        _;\r\n    }\r\n\r\n    modifier marketResolved() {\r\n        require(status == MarketStatus.Resolved, \"Market not resolved\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        string memory _title,\r\n        string memory _description,\r\n        string[] memory _outcomes,\r\n        uint256 _expiryTime,\r\n        address _creator,\r\n        address _oracleAddress,\r\n        uint8 _oracleType,\r\n        address _factory\r\n    ) {\r\n        require(_outcomes.length >= 2, \"Need at least 2 outcomes\");\r\n        require(_expiryTime > block.timestamp, \"Expiry must be in future\");\r\n        \r\n        title = _title;\r\n        description = _description;\r\n        expiryTime = _expiryTime;\r\n        creator = _creator;\r\n        oracleAddress = _oracleAddress;\r\n        oracleType = OracleType(_oracleType);\r\n        factory = _factory;\r\n        status = MarketStatus.Active;\r\n        platformFeeRate = 250; // 2.5% default fee\r\n        \r\n        // Initialize outcomes\r\n        for (uint256 i = 0; i < _outcomes.length; i++) {\r\n            outcomes.push(Outcome({\r\n                name: _outcomes[i],\r\n                totalStaked: 0,\r\n                betCount: 0\r\n            }));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Place a bet on a specific outcome\r\n     * @param _outcome Index of the outcome to bet on\r\n     */\r\n    function placeBet(uint256 _outcome) \r\n        external \r\n        payable \r\n        nonReentrant \r\n        marketActive \r\n        whenNotPaused \r\n    {\r\n        require(_outcome < outcomes.length, \"Invalid outcome\");\r\n        require(msg.value > 0, \"Bet amount must be positive\");\r\n        \r\n        // Record bet\r\n        userBets[msg.sender].push(Bet({\r\n            amount: msg.value,\r\n            outcome: _outcome,\r\n            timestamp: block.timestamp,\r\n            claimed: false\r\n        }));\r\n\r\n        // Update tracking variables\r\n        outcomes[_outcome].totalStaked += msg.value;\r\n        outcomes[_outcome].betCount++;\r\n        outcomeStaked[_outcome] += msg.value;\r\n        userTotalStaked[msg.sender] += msg.value;\r\n        totalVolume += msg.value;\r\n\r\n        // Track unique participants\r\n        if (!hasParticipated[msg.sender]) {\r\n            participants.push(msg.sender);\r\n            hasParticipated[msg.sender] = true;\r\n        }\r\n\r\n        emit BetPlaced(msg.sender, _outcome, msg.value, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev Resolve market with winning outcome\r\n     * @param _winningOutcome Index of the winning outcome\r\n     * @param _resolution Description of resolution\r\n     */\r\n    function resolveMarket(uint256 _winningOutcome, string memory _resolution) \r\n        external \r\n        onlyOracle \r\n        nonReentrant \r\n    {\r\n        require(status == MarketStatus.Active, \"Market not active\");\r\n        require(block.timestamp >= expiryTime, \"Market not expired yet\");\r\n        require(_winningOutcome < outcomes.length, \"Invalid winning outcome\");\r\n        \r\n        status = MarketStatus.Resolved;\r\n        winningOutcome = _winningOutcome;\r\n        resolutionTime = block.timestamp;\r\n        \r\n        emit MarketResolved(_winningOutcome, block.timestamp, _resolution);\r\n    }\r\n\r\n    /**\r\n     * @dev Claim rewards for winning bets\r\n     */\r\n    function claimReward() external nonReentrant marketResolved {\r\n        require(userBets[msg.sender].length > 0, \"No bets found\");\r\n        \r\n        uint256 totalReward = calculateUserReward(msg.sender);\r\n        require(totalReward > 0, \"No rewards to claim\");\r\n        \r\n        // Mark bets as claimed\r\n        for (uint256 i = 0; i < userBets[msg.sender].length; i++) {\r\n            if (userBets[msg.sender][i].outcome == winningOutcome && \r\n                !userBets[msg.sender][i].claimed) {\r\n                userBets[msg.sender][i].claimed = true;\r\n            }\r\n        }\r\n        \r\n        // Calculate platform fee\r\n        uint256 platformFee = (totalReward * platformFeeRate) / 10000;\r\n        uint256 userReward = totalReward - platformFee;\r\n        \r\n        // Transfer rewards\r\n        (bool success, ) = payable(msg.sender).call{value: userReward}(\"\");\r\n        require(success, \"Reward transfer failed\");\r\n        \r\n        // Transfer platform fee to factory\r\n        if (platformFee > 0) {\r\n            (bool feeSuccess, ) = payable(factory).call{value: platformFee}(\"\");\r\n            require(feeSuccess, \"Fee transfer failed\");\r\n        }\r\n        \r\n        emit RewardClaimed(msg.sender, userReward, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate potential reward for a user\r\n     */\r\n    function calculateUserReward(address _user) public view returns (uint256) {\r\n        if (status != MarketStatus.Resolved) return 0;\r\n        \r\n        uint256 userWinningStake = 0;\r\n        \r\n        // Calculate user's winning stakes\r\n        for (uint256 i = 0; i < userBets[_user].length; i++) {\r\n            Bet memory bet = userBets[_user][i];\r\n            if (bet.outcome == winningOutcome && !bet.claimed) {\r\n                userWinningStake += bet.amount;\r\n            }\r\n        }\r\n        \r\n        if (userWinningStake == 0) return 0;\r\n        \r\n        uint256 totalWinningStake = outcomes[winningOutcome].totalStaked;\r\n        if (totalWinningStake == 0) return 0;\r\n        \r\n        // Calculate proportional share of total pool\r\n        return (userWinningStake * totalVolume) / totalWinningStake;\r\n    }\r\n\r\n    /**\r\n     * @dev Get market information\r\n     */\r\n    function getMarketInfo() external view returns (\r\n        string memory _title,\r\n        string memory _description,\r\n        uint256 _totalVolume,\r\n        uint256 _expiryTime,\r\n        MarketStatus _status,\r\n        uint256 _participantCount,\r\n        uint256 _outcomeCount\r\n    ) {\r\n        return (\r\n            title,\r\n            description,\r\n            totalVolume,\r\n            expiryTime,\r\n            status,\r\n            participants.length,\r\n            outcomes.length\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Get all outcomes\r\n     */\r\n    function getOutcomes() external view returns (Outcome[] memory) {\r\n        return outcomes;\r\n    }\r\n\r\n    /**\r\n     * @dev Get user's bets\r\n     */\r\n    function getUserBets(address _user) external view returns (Bet[] memory) {\r\n        return userBets[_user];\r\n    }\r\n\r\n    /**\r\n     * @dev Get market odds for each outcome\r\n     */\r\n    function getOdds() external view returns (uint256[] memory) {\r\n        uint256[] memory odds = new uint256[](outcomes.length);\r\n        \r\n        if (totalVolume == 0) {\r\n            // Equal odds if no bets placed\r\n            for (uint256 i = 0; i < outcomes.length; i++) {\r\n                odds[i] = 10000 / outcomes.length; // Basis points\r\n            }\r\n        } else {\r\n            for (uint256 i = 0; i < outcomes.length; i++) {\r\n                odds[i] = (outcomes[i].totalStaked * 10000) / totalVolume;\r\n            }\r\n        }\r\n        \r\n        return odds;\r\n    }\r\n\r\n    /**\r\n     * @dev Emergency pause (only creator or factory)\r\n     */\r\n    function pause() external {\r\n        require(msg.sender == creator || msg.sender == factory, \"Unauthorized\");\r\n        _pause();\r\n    }\r\n\r\n    /**\r\n     * @dev Unpause (only creator or factory)\r\n     */\r\n    function unpause() external {\r\n        require(msg.sender == creator || msg.sender == factory, \"Unauthorized\");\r\n        _unpause();\r\n    }\r\n\r\n    /**\r\n     * @dev Cancel market and refund all participants\r\n     */\r\n    function cancelMarket(string memory _reason) external onlyFactory {\r\n        require(status == MarketStatus.Active, \"Market not active\");\r\n        \r\n        status = MarketStatus.Cancelled;\r\n        \r\n        // Refund all participants\r\n        for (uint256 i = 0; i < participants.length; i++) {\r\n            address participant = participants[i];\r\n            uint256 totalStaked = userTotalStaked[participant];\r\n            \r\n            if (totalStaked > 0) {\r\n                userTotalStaked[participant] = 0;\r\n                (bool success, ) = payable(participant).call{value: totalStaked}(\"\");\r\n                require(success, \"Refund failed\");\r\n            }\r\n        }\r\n        \r\n        emit MarketCancelled(block.timestamp, _reason);\r\n    }\r\n\r\n    /**\r\n     * @dev Dispute market resolution\r\n     */\r\n    function disputeMarket(string memory _reason) external payable {\r\n        require(status == MarketStatus.Resolved, \"Market not resolved\");\r\n        require(block.timestamp <= resolutionTime + 7 days, \"Dispute period expired\");\r\n        require(msg.value >= 0.1 ether, \"Insufficient dispute bond\");\r\n        \r\n        status = MarketStatus.Disputed;\r\n        \r\n        emit MarketDisputed(msg.sender, block.timestamp, _reason);\r\n    }\r\n\r\n    /**\r\n     * @dev Get participants list\r\n     */\r\n    function getParticipants() external view returns (address[] memory) {\r\n        return participants;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if user has unclaimed rewards\r\n     */\r\n    function hasUnclaimedRewards(address _user) external view returns (bool) {\r\n        if (status != MarketStatus.Resolved) return false;\r\n        return calculateUserReward(_user) > 0;\r\n    }\r\n}"
    },
    "contracts/PredictionMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\nimport \"./PredictionMarket.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n\r\ncontract PredictionMarketFactory is Ownable, ReentrancyGuard {\r\n    struct MarketInfo {\r\n        address marketAddress;\r\n        string title;\r\n        string description;\r\n        uint256 createdAt;\r\n        uint256 expiryTime;\r\n        bool isActive;\r\n        address creator;\r\n        string category;\r\n    }\r\n\r\n    // State variables\r\n    mapping(uint256 => MarketInfo) public markets;\r\n    mapping(address => uint256[]) public userMarkets;\r\n    mapping(string => uint256[]) public categoryMarkets;\r\n    \r\n    uint256 public marketCounter;\r\n    uint256 public marketCreationFee;\r\n    address public oracleAddress;\r\n    address public stakingContract;\r\n    \r\n    // Events\r\n    event MarketCreated(\r\n        uint256 indexed marketId,\r\n        address indexed marketAddress,\r\n        address indexed creator,\r\n        string title,\r\n        string category,\r\n        uint256 expiryTime\r\n    );\r\n    \r\n    event MarketStatusChanged(uint256 indexed marketId, bool isActive);\r\n    event FactoryConfigUpdated(uint256 marketCreationFee, address oracleAddress);\r\n\r\n    constructor(\r\n        uint256 _marketCreationFee,\r\n        address _oracleAddress\r\n    ) Ownable(msg.sender) {\r\n        marketCreationFee = _marketCreationFee;\r\n        oracleAddress = _oracleAddress;\r\n        marketCounter = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a new prediction market\r\n     * @param _title Market title\r\n     * @param _description Market description\r\n     * @param _outcomes Array of possible outcomes\r\n     * @param _expiryTime Market expiry timestamp\r\n     * @param _category Market category\r\n     * @param _oracleType Type of oracle resolution (0: AI, 1: Manual, 2: Hybrid)\r\n     */\r\n    function createMarket(\r\n        string memory _title,\r\n        string memory _description,\r\n        string[] memory _outcomes,\r\n        uint256 _expiryTime,\r\n        string memory _category,\r\n        uint8 _oracleType\r\n    ) external payable nonReentrant returns (address) {\r\n        require(msg.value >= marketCreationFee, \"Insufficient creation fee\");\r\n        require(_expiryTime > block.timestamp, \"Expiry time must be in future\");\r\n        require(_outcomes.length >= 2, \"Must have at least 2 outcomes\");\r\n        require(bytes(_title).length > 0, \"Title cannot be empty\");\r\n\r\n        // Deploy new PredictionMarket contract\r\n        PredictionMarket newMarket = new PredictionMarket(\r\n            _title,\r\n            _description,\r\n            _outcomes,\r\n            _expiryTime,\r\n            msg.sender,\r\n            oracleAddress,\r\n            _oracleType,\r\n            address(this)\r\n        );\r\n\r\n        uint256 marketId = marketCounter++;\r\n        \r\n        // Store market info\r\n        markets[marketId] = MarketInfo({\r\n            marketAddress: address(newMarket),\r\n            title: _title,\r\n            description: _description,\r\n            createdAt: block.timestamp,\r\n            expiryTime: _expiryTime,\r\n            isActive: true,\r\n            creator: msg.sender,\r\n            category: _category\r\n        });\r\n\r\n        // Update mappings\r\n        userMarkets[msg.sender].push(marketId);\r\n        categoryMarkets[_category].push(marketId);\r\n\r\n        emit MarketCreated(\r\n            marketId,\r\n            address(newMarket),\r\n            msg.sender,\r\n            _title,\r\n            _category,\r\n            _expiryTime\r\n        );\r\n\r\n        return address(newMarket);\r\n    }\r\n\r\n    /**\r\n     * @dev Get market information by ID\r\n     */\r\n    function getMarket(uint256 _marketId) external view returns (MarketInfo memory) {\r\n        return markets[_marketId];\r\n    }\r\n\r\n    /**\r\n     * @dev Get all markets (paginated)\r\n     */\r\n    function getMarkets(uint256 _offset, uint256 _limit) \r\n        external \r\n        view \r\n        returns (MarketInfo[] memory) \r\n    {\r\n        require(_offset < marketCounter, \"Offset exceeds market count\");\r\n        \r\n        uint256 end = _offset + _limit;\r\n        if (end > marketCounter) {\r\n            end = marketCounter;\r\n        }\r\n        \r\n        MarketInfo[] memory result = new MarketInfo[](end - _offset);\r\n        \r\n        for (uint256 i = _offset; i < end; i++) {\r\n            result[i - _offset] = markets[i];\r\n        }\r\n        \r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Get markets by category\r\n     */\r\n    function getMarketsByCategory(string memory _category) \r\n        external \r\n        view \r\n        returns (uint256[] memory) \r\n    {\r\n        return categoryMarkets[_category];\r\n    }\r\n\r\n    /**\r\n     * @dev Get markets created by user\r\n     */\r\n    function getUserMarkets(address _user) \r\n        external \r\n        view \r\n        returns (uint256[] memory) \r\n    {\r\n        return userMarkets[_user];\r\n    }\r\n\r\n    /**\r\n     * @dev Get active markets only\r\n     */\r\n    function getActiveMarkets(uint256 _offset, uint256 _limit) \r\n        external \r\n        view \r\n        returns (MarketInfo[] memory) \r\n    {\r\n        // Count active markets first\r\n        uint256 activeCount = 0;\r\n        for (uint256 i = 0; i < marketCounter; i++) {\r\n            if (markets[i].isActive) {\r\n                activeCount++;\r\n            }\r\n        }\r\n\r\n        require(_offset < activeCount, \"Offset exceeds active market count\");\r\n        \r\n        uint256 end = _offset + _limit;\r\n        if (end > activeCount) {\r\n            end = activeCount;\r\n        }\r\n        \r\n        MarketInfo[] memory result = new MarketInfo[](end - _offset);\r\n        uint256 resultIndex = 0;\r\n        uint256 activeIndex = 0;\r\n        \r\n        for (uint256 i = 0; i < marketCounter && resultIndex < (end - _offset); i++) {\r\n            if (markets[i].isActive) {\r\n                if (activeIndex >= _offset) {\r\n                    result[resultIndex] = markets[i];\r\n                    resultIndex++;\r\n                }\r\n                activeIndex++;\r\n            }\r\n        }\r\n        \r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Toggle market active status (only owner)\r\n     */\r\n    function toggleMarketStatus(uint256 _marketId) external onlyOwner {\r\n        require(_marketId < marketCounter, \"Market does not exist\");\r\n        \r\n        markets[_marketId].isActive = !markets[_marketId].isActive;\r\n        emit MarketStatusChanged(_marketId, markets[_marketId].isActive);\r\n    }\r\n\r\n    /**\r\n     * @dev Update factory configuration (only owner)\r\n     */\r\n    function updateConfig(\r\n        uint256 _marketCreationFee,\r\n        address _oracleAddress\r\n    ) external onlyOwner {\r\n        marketCreationFee = _marketCreationFee;\r\n        oracleAddress = _oracleAddress;\r\n        \r\n        emit FactoryConfigUpdated(_marketCreationFee, _oracleAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Set staking contract address (only owner)\r\n     */\r\n    function setStakingContract(address _stakingContract) external onlyOwner {\r\n        stakingContract = _stakingContract;\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw accumulated fees (only owner)\r\n     */\r\n    function withdrawFees() external onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"No fees to withdraw\");\r\n        \r\n        (bool success, ) = payable(owner()).call{value: balance}(\"\");\r\n        require(success, \"Fee withdrawal failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Get total market count\r\n     */\r\n    function getTotalMarkets() external view returns (uint256) {\r\n        return marketCounter;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if market exists\r\n     */\r\n    function marketExists(uint256 _marketId) external view returns (bool) {\r\n        return _marketId < marketCounter;\r\n    }\r\n}"
    },
    "contracts/StakingContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\ncontract StakingContract is ReentrancyGuard, Ownable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    struct StakeInfo {\r\n        uint256 amount;\r\n        uint256 timestamp;\r\n        uint256 lockPeriod; // in seconds\r\n        uint256 rewardDebt;\r\n        bool isValidator;\r\n    }\r\n\r\n    struct Validator {\r\n        address validatorAddress;\r\n        uint256 totalStaked;\r\n        uint256 reputation; // 0-1000\r\n        uint256 successfulResolutions;\r\n        uint256 totalResolutions;\r\n        bool isActive;\r\n        uint256 slashCount;\r\n    }\r\n\r\n    // State variables\r\n    IERC20 public orxToken;\r\n    \r\n    mapping(address => StakeInfo) public stakes;\r\n    mapping(address => Validator) public validators;\r\n    address[] public validatorList;\r\n    \r\n    uint256 public totalStaked;\r\n    uint256 public rewardRate; // Reward per second per token (scaled by 1e18)\r\n    uint256 public lastUpdateTime;\r\n    uint256 public rewardPerTokenStored;\r\n    uint256 public minimumValidatorStake;\r\n    uint256 public minimumStakingPeriod;\r\n    uint256 public slashingRate; // Percentage to slash (basis points)\r\n    \r\n    mapping(address => uint256) public userRewardPerTokenPaid;\r\n    mapping(address => uint256) public rewards;\r\n\r\n    // Events\r\n    event TokensStaked(address indexed user, uint256 amount, uint256 lockPeriod, bool isValidator);\r\n    event TokensUnstaked(address indexed user, uint256 amount);\r\n    event RewardClaimed(address indexed user, uint256 reward);\r\n    event ValidatorRegistered(address indexed validator, uint256 stakedAmount);\r\n    event ValidatorSlashed(address indexed validator, uint256 slashedAmount, string reason);\r\n    event RewardsDistributed(uint256 totalRewards, uint256 rewardRate);\r\n\r\n    modifier updateReward(address account) {\r\n        rewardPerTokenStored = rewardPerToken();\r\n        lastUpdateTime = block.timestamp;\r\n\r\n        if (account != address(0)) {\r\n            rewards[account] = earned(account);\r\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier validatorOnly() {\r\n        require(validators[msg.sender].isActive, \"Not an active validator\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _orxToken,\r\n        uint256 _rewardRate,\r\n        uint256 _minimumValidatorStake,\r\n        uint256 _minimumStakingPeriod,\r\n        uint256 _slashingRate\r\n    ) Ownable(msg.sender) {\r\n        orxToken = IERC20(_orxToken);\r\n        rewardRate = _rewardRate;\r\n        minimumValidatorStake = _minimumValidatorStake;\r\n        minimumStakingPeriod = _minimumStakingPeriod;\r\n        slashingRate = _slashingRate;\r\n        lastUpdateTime = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev Stake ORX tokens\r\n     * @param _amount Amount of tokens to stake\r\n     * @param _lockPeriod Lock period in seconds\r\n     * @param _asValidator Whether to register as validator\r\n     */\r\n    function stakeTokens(\r\n        uint256 _amount,\r\n        uint256 _lockPeriod,\r\n        bool _asValidator\r\n    ) external nonReentrant updateReward(msg.sender) {\r\n        require(_amount > 0, \"Cannot stake 0 tokens\");\r\n        require(_lockPeriod >= minimumStakingPeriod, \"Lock period too short\");\r\n        \r\n        if (_asValidator) {\r\n            require(_amount >= minimumValidatorStake, \"Insufficient stake for validator\");\r\n            require(!validators[msg.sender].isActive, \"Already a validator\");\r\n        }\r\n\r\n        // Transfer tokens from user\r\n        orxToken.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        // Update stake info\r\n        StakeInfo storage stake = stakes[msg.sender];\r\n        stake.amount += _amount;\r\n        stake.timestamp = block.timestamp;\r\n        stake.lockPeriod = _lockPeriod;\r\n        stake.isValidator = _asValidator;\r\n\r\n        totalStaked += _amount;\r\n\r\n        // Register as validator if requested\r\n        if (_asValidator) {\r\n            _registerValidator(msg.sender, _amount);\r\n        }\r\n\r\n        emit TokensStaked(msg.sender, _amount, _lockPeriod, _asValidator);\r\n    }\r\n\r\n    /**\r\n     * @dev Unstake tokens\r\n     * @param _amount Amount to unstake\r\n     */\r\n    function unstakeTokens(uint256 _amount) \r\n        external \r\n        nonReentrant \r\n        updateReward(msg.sender) \r\n    {\r\n        StakeInfo storage stake = stakes[msg.sender];\r\n        require(stake.amount >= _amount, \"Insufficient staked amount\");\r\n        require(\r\n            block.timestamp >= stake.timestamp + stake.lockPeriod,\r\n            \"Tokens still locked\"\r\n        );\r\n\r\n        // If validator, check if they can unstake\r\n        if (stake.isValidator && validators[msg.sender].isActive) {\r\n            require(\r\n                stake.amount - _amount >= minimumValidatorStake || _amount == stake.amount,\r\n                \"Would fall below minimum validator stake\"\r\n            );\r\n            \r\n            if (_amount == stake.amount) {\r\n                // Remove validator status\r\n                validators[msg.sender].isActive = false;\r\n                _removeFromValidatorList(msg.sender);\r\n            }\r\n        }\r\n\r\n        // Update stake\r\n        stake.amount -= _amount;\r\n        totalStaked -= _amount;\r\n\r\n        if (stake.amount == 0) {\r\n            delete stakes[msg.sender];\r\n        }\r\n\r\n        // Transfer tokens back to user\r\n        orxToken.safeTransfer(msg.sender, _amount);\r\n\r\n        emit TokensUnstaked(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Claim staking rewards\r\n     */\r\n    function claimRewards() external nonReentrant updateReward(msg.sender) {\r\n        uint256 reward = rewards[msg.sender];\r\n        require(reward > 0, \"No rewards to claim\");\r\n\r\n        rewards[msg.sender] = 0;\r\n        orxToken.safeTransfer(msg.sender, reward);\r\n\r\n        emit RewardClaimed(msg.sender, reward);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate current reward per token\r\n     */\r\n    function rewardPerToken() public view returns (uint256) {\r\n        if (totalStaked == 0) {\r\n            return rewardPerTokenStored;\r\n        }\r\n        return\r\n            rewardPerTokenStored +\r\n            (((block.timestamp - lastUpdateTime) * rewardRate * 1e18) / totalStaked);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate earned rewards for an account\r\n     */\r\n    function earned(address account) public view returns (uint256) {\r\n        return\r\n            ((stakes[account].amount *\r\n                (rewardPerToken() - userRewardPerTokenPaid[account])) / 1e18) +\r\n            rewards[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Register as validator\r\n     */\r\n    function _registerValidator(address _validator, uint256 _stakedAmount) internal {\r\n        validators[_validator] = Validator({\r\n            validatorAddress: _validator,\r\n            totalStaked: _stakedAmount,\r\n            reputation: 500, // Start with medium reputation\r\n            successfulResolutions: 0,\r\n            totalResolutions: 0,\r\n            isActive: true,\r\n            slashCount: 0\r\n        });\r\n\r\n        validatorList.push(_validator);\r\n\r\n        emit ValidatorRegistered(_validator, _stakedAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove validator from list\r\n     */\r\n    function _removeFromValidatorList(address _validator) internal {\r\n        for (uint256 i = 0; i < validatorList.length; i++) {\r\n            if (validatorList[i] == _validator) {\r\n                validatorList[i] = validatorList[validatorList.length - 1];\r\n                validatorList.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Slash validator stake for malicious behavior\r\n     */\r\n    function slashStake(address _validator, string memory _reason) \r\n        external \r\n        onlyOwner \r\n        updateReward(_validator) \r\n    {\r\n        require(validators[_validator].isActive, \"Validator not active\");\r\n        \r\n        StakeInfo storage stake = stakes[_validator];\r\n        uint256 slashAmount = (stake.amount * slashingRate) / 10000;\r\n        \r\n        if (slashAmount > stake.amount) {\r\n            slashAmount = stake.amount;\r\n        }\r\n\r\n        // Update stake\r\n        stake.amount -= slashAmount;\r\n        totalStaked -= slashAmount;\r\n\r\n        // Update validator info\r\n        validators[_validator].slashCount++;\r\n        validators[_validator].reputation = validators[_validator].reputation > 100 ? \r\n            validators[_validator].reputation - 100 : 0;\r\n\r\n        // If stake falls below minimum, deactivate validator\r\n        if (stake.amount < minimumValidatorStake) {\r\n            validators[_validator].isActive = false;\r\n            _removeFromValidatorList(_validator);\r\n        }\r\n\r\n        // Burn slashed tokens (send to dead address)\r\n        orxToken.safeTransfer(address(0x000000000000000000000000000000000000dEaD), slashAmount);\r\n\r\n        emit ValidatorSlashed(_validator, slashAmount, _reason);\r\n    }\r\n\r\n    /**\r\n     * @dev Distribute rewards to stakers\r\n     */\r\n    function distributeRewards(uint256 _rewardAmount) \r\n        external \r\n        onlyOwner \r\n        updateReward(address(0)) \r\n    {\r\n        require(_rewardAmount > 0, \"No rewards to distribute\");\r\n        \r\n        // Transfer reward tokens to contract\r\n        orxToken.safeTransferFrom(msg.sender, address(this), _rewardAmount);\r\n\r\n        emit RewardsDistributed(_rewardAmount, rewardRate);\r\n    }\r\n\r\n    /**\r\n     * @dev Update validator performance\r\n     */\r\n    function updateValidatorPerformance(\r\n        address _validator,\r\n        bool _successful\r\n    ) external onlyOwner {\r\n        require(validators[_validator].isActive, \"Validator not active\");\r\n        \r\n        Validator storage validator = validators[_validator];\r\n        validator.totalResolutions++;\r\n        \r\n        if (_successful) {\r\n            validator.successfulResolutions++;\r\n            // Increase reputation for successful resolution\r\n            if (validator.reputation < 1000) {\r\n                validator.reputation += 10;\r\n            }\r\n        } else {\r\n            // Decrease reputation for failed resolution\r\n            if (validator.reputation > 10) {\r\n                validator.reputation -= 10;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get validator list\r\n     */\r\n    function getValidators() external view returns (address[] memory) {\r\n        return validatorList;\r\n    }\r\n\r\n    /**\r\n     * @dev Get active validators only\r\n     */\r\n    function getActiveValidators() external view returns (address[] memory) {\r\n        uint256 activeCount = 0;\r\n        \r\n        // Count active validators\r\n        for (uint256 i = 0; i < validatorList.length; i++) {\r\n            if (validators[validatorList[i]].isActive) {\r\n                activeCount++;\r\n            }\r\n        }\r\n\r\n        // Build active validators array\r\n        address[] memory activeValidators = new address[](activeCount);\r\n        uint256 index = 0;\r\n        \r\n        for (uint256 i = 0; i < validatorList.length; i++) {\r\n            if (validators[validatorList[i]].isActive) {\r\n                activeValidators[index] = validatorList[i];\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return activeValidators;\r\n    }\r\n\r\n    /**\r\n     * @dev Update contract parameters\r\n     */\r\n    function updateParameters(\r\n        uint256 _rewardRate,\r\n        uint256 _minimumValidatorStake,\r\n        uint256 _minimumStakingPeriod,\r\n        uint256 _slashingRate\r\n    ) external onlyOwner {\r\n        rewardRate = _rewardRate;\r\n        minimumValidatorStake = _minimumValidatorStake;\r\n        minimumStakingPeriod = _minimumStakingPeriod;\r\n        slashingRate = _slashingRate;\r\n    }\r\n\r\n    /**\r\n     * @dev Get stake info for user\r\n     */\r\n    function getStakeInfo(address _user) external view returns (StakeInfo memory) {\r\n        return stakes[_user];\r\n    }\r\n\r\n    /**\r\n     * @dev Get validator info\r\n     */\r\n    function getValidatorInfo(address _validator) external view returns (Validator memory) {\r\n        return validators[_validator];\r\n    }\r\n\r\n    /**\r\n     * @dev Check if address is active validator\r\n     */\r\n    function isActiveValidator(address _validator) external view returns (bool) {\r\n        return validators[_validator].isActive;\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}